# 目录

[toc]



# 自媒体

1. B站：视频

2. GitHub：代码+md



# 一、语言基础

## 1、三种智能指针

### 1.1基本知识

智能指针**主要作用**：自动管理动态分配的内存，确保在不再需要时能够正确地释放内存资源，从而避免内存泄漏。智能指针通过在对象的生命周期结束时自动调用析构函数来实现这一点。

- `std::unique_ptr` 适用于**独占**资源管理，确保资源在不再需要时被自动释放。
- `std::shared_ptr` 适用于多个指针**共享**资源所有权的场景，确保资源在最后一个指针被销毁时被释放。
- `std::weak_ptr` 适用于解决 `std::shared_ptr` 可能导致的**循环引用**问题，它不拥有资源，但可以观察资源是否还存在。

通过合理使用这些智能指针，可以有效地管理资源的生命周期，避免内存泄漏和资源竞争等问题。



### 1.2问问题

a.独占怎么体现？

1. 1.**单一所有权**：`std::unique_ptr` 确保在任何时刻，只有一个 `std::unique_ptr` 实例拥有对所管理对象的所有权。这意味着，当一个 `std::unique_ptr` 实例被销毁或被重新赋值给另一个对象时，它所管理的对象也会被自动销毁。

2. 2.**不允许复制**：`std::unique_ptr` 不支持复制操作。尝试复制一个 `std::unique_ptr` 实例会导致编译错误。这确保了所有权的唯一性，防止了多个 `std::unique_ptr` 实例同时拥有同一个对象的所有权。

3. 3.**支持移动语义**：`std::unique_ptr` 支持移动操作，允许将所有权从一个 `std::unique_ptr` 实例转移到另一个。当所有权被移动后，原来的 `std::unique_ptr` 实例将不再拥有对象的所有权，而新的 `std::unique_ptr` 实例将拥有。

b,共享怎么体现？

use_count()

c.循环引用 

d.Weak connection is still available. Use count: 3



### 1.3实操

全部重新写一遍

